<html>

<head>
<title> Friend Mapper!</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta property="og:title" content="Friend Mapper"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://petercottle.com/friendMapper2/index.html"/>
<meta property="og:image" content="http://petercottle.com/friendMapper2/friendMapperIcon.PNG"/>
<meta property="og:site_name" content="FriendMapper"/>
<meta property="og:description" content="Map your friends in 3D with WebGl and the Facebook Graph API! Coded by Peter Cottle"/>

<link href="style.css" rel="stylesheet" type="text/css"/>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="Tween.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

<script id="shader-box-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;

uniform float time;
uniform float minX;
uniform float minY;
uniform float maxX;
uniform float maxY;
uniform float minZ;
uniform float maxZ;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

varying vec4 vColor;
varying vec4 vPos;

float convertZToG(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return g;
}


float convertZToB(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return b;
}


float convertZToR(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return r;
}


void main(void) {
    float x, y, z;
    float xOriginal, yOriginal;

    xOriginal = aVertexPosition[0];
    yOriginal = aVertexPosition[1];

    //the x and y go from -1 to 1 on the master grid, so
    //rescale these to be from -minX to +maxX
    x = ((aVertexPosition[0] + 1.0)/(2.0)) * (maxX - minX) + minX;
    y = ((aVertexPosition[1] + 1.0)/(2.0)) * (maxY - minY) + minY;
    z = 0.0;

    z = pow(x,2.0) + pow(y,2.0);
    z = 2.0 * cos(time + x + y) * (0.5 + (sin(x*x + y*x + time) - 0.5)/(1.0 + 0.1*(x * x + y * y + cos(time))));
    //z = 0.3 * ((x * sin(sqrt(abs(x - (y + 9.0)))) - (y + 9.0) * sin(sqrt(abs(y + 0.5 * x + 9.0))));

    float r,g,b;

    //scale the z so it fits within our window
    float zScaled = ((z - minZ)/(maxZ - minZ)) * 2.0 + -1.0;

    r = convertZToR(zScaled);
    g = convertZToG(zScaled);
    b = convertZToB(zScaled);

    vec4 position = vec4(aVertexPosition[0],aVertexPosition[1],zScaled,1.0);
    //vec4 anotherPos = vec4(xOriginal / 100.0,0.0,zScaled,1.0);

    gl_Position = uPMatrix * uMVMatrix * position;
    //gl_Position = uPMatrix * uMVMatrix * anotherPos;

    vPos = position;
    vColor = vec4(r,g,b,0.9);
}
</script>

<script id="shader-box-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;
varying vec4 vPos;

float convertZToG(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return g;
}


float convertZToB(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return b;
}


float convertZToR(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return r;
}



void main(void) {
    float z = (vPos[2] + 1.0) * 2.0;
    float r,g,b;

    r = convertZToR(z);
    g = convertZToG(z);
    b = convertZToB(z);

    gl_FragColor = vec4(r,g,b,1);
    //gl_FragColor = vec4(z,0,0,1);
    //gl_FragColor = vColor;
}

</script>


<script type="text/javascript">

//function globals
//board bounds
var sym = 3;

var minX = -sym;
var maxX = sym;
var minY = -sym;
var maxY = sym;

var minZ = -5;
var maxZ = 5;

var gl;
$j = jQuery.noConflict();

//globals
var boxTimeout = null;
var notifyTimeout = null;

var shouldCircuit = false;
var thePopup = null;
var canvas = null;

//camera stuff
var zoomAmount = -2;
var currentZoomLevel = -6;

var scaleAmount = 1;
var ourScaleTween = null;
var scaleVariablesForTween = null;

var globalYrotate = 0;
var globalXrotate = -45;
var angleLimit = 85;
var rotateOn = false;

var rotVariablesForTween = {'x':globalXrotate,'y':globalYrotate};
var ourTween = null;
var tweenTime = 1000;
var tweenEasing = TWEEN.Easing.Cubic.EaseInOut;
var ourTweenOn = false;
var timeoutMinutes = 10;
var timeOnLoad = new Date();
var startTime = timeOnLoad.getTime();


/*****************CLASSES*******************/


/***************End Classes!*****************************/


/********** Geometry Functions *******/

function zeroPad(num,count)
{
    var numZeropad = String(num);
    while(numZeropad.length < count) {
        numZeropad = "0" + numZeropad;
    }
    return numZeropad;
}


/*******************End Geometry Functions******************/

function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl",{preserveDrawingBuffer:true});
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {
    }
    if (!gl || /Firefox/.test(navigator.userAgent)) {

        if(/Safari/.test(navigator.userAgent))
        {
            window.location = "http://petercottle.com/friendMapper2/safari.html";
        }
        else
        {
            window.location = "http://petercottle.com/friendMapper2/browserFail.html";
        }
    }
}

function onMouseWheel(event) {

    //first, check if this was a scroll inside a popup thing
    if(event.originalEvent && event.originalEvent.srcElement)
    {
        if(determineIfInPopup(event.originalEvent.srcElement))
        {
            //console.log("was in bubble div");
            //dont do stupid zoom stuff
            return;
        }
        else
        {
            //console.log("not in bubble div");
        }
    }

    var toZoom = 0;
    if(event.originalEvent.wheelDeltaY)
    {
        toZoom = event.originalEvent.wheelDeltaY * 0.003;
    }
    else
    {
        //friggin firefox...
        toZoom = -1 * event.originalEvent.detail * 0.06;
    }

    zoomAmount += toZoom;
    if(zoomAmount > -0.76)
    {
        zoomAmount = -0.76;
    }
}

function resizeWindow()
{
    //fix other frame buffer size...?
    initOtherFrameBuffer();

    //window sizes
    var wHeight = $j(window).height();
    var wWidth = $j(window).width();

    //viewport sizes
    vHeight = wHeight;
    vWidth = wWidth;

    //set the width to the canvas
    $j('#earth-canvas').attr('width',String(vWidth) + 'px');
    $j('#earth-canvas').attr('height',String(vHeight) + 'px');

    gl.viewportWidth = vWidth;
    gl.viewportHeight = vHeight; 
    gl.viewport(0,0,vWidth,vHeight);

    mat4.perspective(45,gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

    setMatrixUniforms();


     $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    //fix loading gif
    
}


function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//global colors

var blendShaderProgram;

function initShaders() {
    //box shadeer
    var blendVertexShader = getShader(gl, "shader-box-vs");
    var blendFragShader = getShader(gl, "shader-box-fs");

    blendShaderProgram = gl.createProgram();
    gl.attachShader(blendShaderProgram, blendVertexShader);
    gl.attachShader(blendShaderProgram, blendFragShader);
    gl.linkProgram(blendShaderProgram);

    if (!gl.getProgramParameter(blendShaderProgram, gl.LINK_STATUS))
    {
        alert("Could not initialise shaders");
    }

    //our arcs
    gl.useProgram(blendShaderProgram);

    blendShaderProgram.vertexPositionAttribute = gl.getAttribLocation(blendShaderProgram,"aVertexPosition");
    gl.enableVertexAttribArray(blendShaderProgram.vertexPositionAttribute);

    blendShaderProgram.pMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uPMatrix");
    blendShaderProgram.mvMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uMVMatrix");


    blendShaderProgram.timeUniform = gl.getUniformLocation(blendShaderProgram,"time");
    blendShaderProgram.uniformMinX = gl.getUniformLocation(blendShaderProgram,"minX");
    blendShaderProgram.uniformMaxX = gl.getUniformLocation(blendShaderProgram,"maxX");
    blendShaderProgram.uniformMinY = gl.getUniformLocation(blendShaderProgram,"minY");
    blendShaderProgram.uniformMaxY = gl.getUniformLocation(blendShaderProgram,"maxY");
    blendShaderProgram.uniformMinZ = gl.getUniformLocation(blendShaderProgram,"minZ");
    blendShaderProgram.uniformMaxZ = gl.getUniformLocation(blendShaderProgram,"maxZ");
    
}



var earthTexture;
var otherFramebuffer;
var otherTexture;

function initOtherFrameBuffer() {
    //make frame buffer
    otherFramebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,otherFramebuffer);
    otherFramebuffer.width = $j(window).width();
    otherFramebuffer.height = $j(window).height();

    //something with a render buffer?
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, otherFramebuffer.width, otherFramebuffer.height);

    //reset back to default
    gl.bindTexture(gl.TEXTURE_2D,null);
    gl.bindRenderbuffer(gl.RENDERBUFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

var mvMatrix = mat4.create();
var mvMatrixStack = [];
var pMatrix = mat4.create();

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

function setMatrixUniforms() {

    gl.uniformMatrix4fv(blendShaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(blendShaderProgram.mvMatrixUniform, false, mvMatrix);

    var now = new Date();
    var deltaT = (now.getTime() - startTime) / 1000.0;

    //all the things that change
    gl.uniform1f(blendShaderProgram.timeUniform,deltaT);
    gl.uniform1f(blendShaderProgram.uniformMinX,minX);
    gl.uniform1f(blendShaderProgram.uniformMaxX,maxX);
    gl.uniform1f(blendShaderProgram.uniformMinY,minY);
    gl.uniform1f(blendShaderProgram.uniformMaxY,maxY);
    gl.uniform1f(blendShaderProgram.uniformMinZ,minZ);
    gl.uniform1f(blendShaderProgram.uniformMaxZ,maxZ);
}


function degToRad(degrees) {
    return degrees * Math.PI / 180;
}


var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var earthRotationMatrix = mat4.create();
mat4.identity(earthRotationMatrix);

function handleMouseDown(event) {
    //event.preventDefault();
    mouseDown = true;

    if(event.which == 1)
    {
        //primary click
        
        //dont do anything if we are inside a bubble thing
        if(determineIfInPopup(event.srcElement))
        {
            return;
        }

        mouseClickPick(event);
        //return;
    }

    //otherwise, move with mouse
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}


function handleMouseUp(event) {
    mouseDown = false;
}


function handleMouseMove(event) {
    //phantom events
    if(event.clientX == lastMouseX && event.clientY == lastMouseY)
    {
        return;
    }

    if (!mouseDown) {
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        return;
    }
    //this here only executes when we are clicking and dragging mouse

    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;
    var deltaY = newY - lastMouseY;

    globalYrotate += deltaX / 10;
    globalXrotate += deltaY / 10;

    if(globalXrotate > angleLimit)
    {
        globalXrotate = angleLimit;
    }
    else if (globalXrotate < -angleLimit)
    {
        globalXrotate = -angleLimit;
    }

    lastMouseX = newX
    lastMouseY = newY;
}



var gridVertexPositionBuffer;

var vertices;
var colors;

function initGridBuffers() {

    //initialize the grid vertices
    var gridVertexPositions = [];

    var addPointsToBuffer = function() {
        for(var temp = 0; temp < arguments.length; temp++)
        {
            point = arguments[temp];
            gridVertexPositions.push(point.x, point.y, 0);
        }
    };

    var makePoint = function(x,y) {
        return {'x':x,'y':y};
    };

    var numRows = 70.0;

    var xMinBoard = -1;
    var xMaxBoard = 1;
    var yMinBoard = -1;
    var yMaxBoard = 1;

    var xDivisor = (xMaxBoard - xMinBoard) / numRows;
    console.log(xDivisor);
    var yDivisor = (yMaxBoard - yMinBoard) / numRows;
    //the x loop
    for(var i = 0; i < numRows; i++)
    {
        //the y loop
        for(var j = 0; j < numRows; j++)
        {
            var xHere = i * xDivisor + xMinBoard;
            var yHere = j * yDivisor + yMinBoard;

            var xAcross = (i + 1) * xDivisor + xMinBoard;
            var yAcross = (j + 1) * yDivisor + yMinBoard;

            var pHere = makePoint(xHere,yHere);
            var pAbove = makePoint(xHere,yAcross);
            var pRight = makePoint(xAcross,yHere);
            var pDiagonal = makePoint(xAcross,yAcross);

            addPointsToBuffer(pHere,pDiagonal,pAbove);
            addPointsToBuffer(pHere,pRight,pDiagonal);
        }
    }

    //gridVertexPositions = [1,1,0,-1,-1,0,-1,1,0];

    gridVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVertexPositions), gl.STATIC_DRAW);
    gridVertexPositionBuffer.itemSize = 3;
    gridVertexPositionBuffer.numItems = gridVertexPositions.length / 3;

}

function startLoadingWithText(theText) {
    startLoading();
    topNotify(theText);
}

function stopLoadingWithText() {
    stopLoading();
    topNotifyClear();
}

function topNotifyClear() {
    $j('#topNotifyBar').html('');
    $j('#topNotifyBarHolder').addClass('topNotifyBarHidden');
}

function startLoading() {
    isLoading = true;

    var wHeight = $j(window).height();
    var wWidth = $j(window).width();
    $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    $j('.loadingGif').fadeIn();
}

function stopLoading() {
    isLoading = false;
    $j('.loadingGif').fadeOut();
}


function topNotify(theText) {
    topNotifyHtml("<h1>" + theText + "</h1>");
}

function topNotifyHtml(theText) {
    //and if someone is clicking fast, get rid of it
    if(notifyTimeout)
    {
        clearTimeout(notifyTimeout);
    }

    //basically, if its already displayed, hide it and come back in 700ms
    if(!$j('#topNotifyBarHolder').hasClass('topNotifyBarHidden'))
    {
        //clear and come back
        topNotifyClear();
        var jsToExecute = "topNotifyHtml('" + theText + "');";
        notifyTimeout = setTimeout(jsToExecute,700);
        return;
    }

    $j('#topNotifyBar').html("<h1>" + theText + "</h1>");

    $j('#topNotifyBarHolder').removeClass('topNotifyBarHidden');
}


function mouseClickPick(event) {
    //get the coordinates on our canvas
    var x = event.clientX;
    var y = event.clientY;

}

/*
function getArcAtMousePos(x,y) {
    ***********this is old but i want to reference this code later!!!***
    //flip y
    y = gl.viewportHeight - y;

    //real quick, render the frame but in pick mode into another buffer!
    gl.bindFramebuffer(gl.FRAMEBUFFER, otherFramebuffer);
    drawSceneIntoOtherBuffer();

    //go get the pixel data from the frame buffer
    var pixelValues = new Uint8Array(4);
    gl.readPixels(x,y,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixelValues);

    //now switch back
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    //console.log("R:" + pixelValues[0] + " G:" + pixelValues[1] + " B:" + pixelValues[2]);

    var r = pixelValues[0]; var rS = zeroPad(r,3);
    var g = pixelValues[1]; var gS = zeroPad(g,3);
    var b = pixelValues[2]; var bS = zeroPad(b,3);

    //get the string for this
    var cString = rS + gS + bS;
    
    //see if its there
    if(globalColorTaken[cString])
    {
        //also tell who it is
        var theArc = globalColorLookup[cString];
        return theArc;
    }
    return null;
}
*/

function drawSceneIntoOtherBuffer() {
    drawSceneEither(true);
}

function drawScene() {
    drawSceneEither(false);
}

function drawSceneEither(forPicking) {

    cameraPerspectiveClear();
    translateAndRotate();

    gl.useProgram(blendShaderProgram);
    setMatrixUniforms();
    //here, we draw the grid
    drawGrid();

}

function cameraPerspectiveClear() {

    gl.useProgram(blendShaderProgram);
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

    //we set our clearColor to be 0 0 0 0, so its essentially transparent.
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
}


function translateAndRotate() {

    mat4.identity(mvMatrix);

    mat4.translate(mvMatrix, [0, 0, zoomAmount]);

    //cap variables
    if(globalYrotate > 360)
    {
        globalYrotate -= 360;
    }
    if(globalYrotate < -360)
    {
        globalYrotate += 360;
    }

    //do rotation for camera
    var newRot = mat4.create();
    mat4.identity(newRot);

    //now need to get the other axis
    var secondRotAxis = vec3.create();
    var result = vec3.create();
    secondRotAxis[0] = 1;
    mat4.multiplyVec3(newRot,secondRotAxis,result);

    mat4.rotate(newRot,degToRad(globalXrotate), [result[0],result[1],result[2]]);
    mat4.rotate(newRot,degToRad(globalYrotate), [0,1,0]);

    //now multiply earth rotation
    mat4.identity(earthRotationMatrix);
    mat4.multiply(earthRotationMatrix,newRot);

    mat4.scale(mvMatrix,[scaleAmount,scaleAmount,scaleAmount]);

    mat4.multiply(mvMatrix, earthRotationMatrix);
    setMatrixUniforms();
}


function drawGrid() {
    gl.useProgram(blendShaderProgram);
    setMatrixUniforms();

    //need a new buffer for grid positions
    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexPositionAttribute, gridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.drawArrays(gl.TRIANGLES, 0, gridVertexPositionBuffer.numItems);
}


function tweenUpdate() {
    globalXrotate = rotVariablesForTween.x;
    globalYrotate = rotVariablesForTween.y;
}

function tweenDone() {
    ourTweenOn = false;
}

function tick() {
    requestAnimFrame(tick);
    drawScene();
}


function webGLStart() {
    startLoadingWithText("Initializing WebGL...");
   
    canvas = document.getElementById("earth-canvas");
    initGL(canvas);
    initShaders();
    initGridBuffers();

    initOtherFrameBuffer();

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.enable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    document.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    //do the finish down here
    stopLoadingWithText();
    doEarthFlyin();
    tick();
}

function doEarthFlyin() {
    scaleAmount = 0.01;
    if(ourScaleTween)
    {
        ourScaleTween.stop();
    }

    scaleVariablesForTween = {'scale':scaleAmount};

    ourScaleTween = new TWEEN.Tween(scaleVariablesForTween).to({'scale':1},tweenTime*1.5).onUpdate(scaleTweenUpdate);
    setTimeout('scaleTweenComplete()',tweenTime*0.5);
    ourScaleTween.easing(TWEEN.Easing.Quartic.EaseInOut);
    ourScaleTween.start();
} 

function scaleTweenComplete()
{
    //code here possibly
}

function scaleTweenUpdate() {
    scaleAmount = scaleVariablesForTween.scale;
}

$j(document).ready(function(){
    TWEEN.start();
    webGLStart();

    $j(window).resize(function(){resizeWindow();});
    //initial resize
    resizeWindow();

    $j(document).bind('mousewheel',onMouseWheel);
    $j(document).bind('DOMMouseScroll',onMouseWheel);
});

</script>


</head>


<body>

    <canvas id="earth-canvas" style="border: none;" width="500px" height="500px"></canvas>

<img src="loading.gif"class="loadingGif"/>

<div id="topNotifyBarWrapper" style="width:100%;text-align:center;position:absolute;top:0px;">
    <div id="topNotifyBarHolder" class="buttonGradient smooth topNotifyBar topNotifyBarHidden bubbleToStop" onclick="topNotifyClear()" style="display:inline-block;cursor:pointer">
        <div id="topNotifyBar">

        </div>
    </div>
</div>

<div id="countdownClockHolder" class="buttonGradient smooth countdownClockHolder">
    <div id="countdownClock" class="countdownClockText">

    </div>
    Until next Query..
</div>


</body>

</html>
