<html>

<head>
<title> Genetic GPU!</title>
<!--
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta property="og:title" content="Genetic GPU"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://petercottle.com/friendMapper2/index.html"/>
<meta property="og:image" content="http://petercottle.com/friendMapper2/friendMapperIcon.PNG"/>
<meta property="og:site_name" content="FriendMapper"/>
<meta property="og:description" content="Map your friends in 3D with WebGl and the Facebook Graph API! Coded by Peter Cottle"/>
-->

<link href="style.css" rel="stylesheet" type="text/css"/>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="Tween.js"></script>
<!--<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>-->
<script type="text/javascript" src="jquery-1.6.1.min.js"></script>
<script type="text/javascript" src="geneticGPU.js"></script>

<script id="shader-simple-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec4 aVertexColor;

uniform mat4 mvMatrix;
uniform mat4 pMatrix;

uniform float xPos;
uniform float yPos;
uniform float zPos;

varying vec4 vColor;

void main(void) {
    vec4 translatedPos = vec4(aVertexPosition[0] + xPos, aVertexPosition[1] + yPos, aVertexPosition[2] + zPos, 1.0);

    gl_Position = pMatrix * mvMatrix * translatedPos;
    vColor = aVertexColor;
}
</script>

<script id="shader-simple-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
    gl_FragColor = vColor;
}

</script>

<script id="shader-box-vs" type="x-shader/x-vertex">
#ifdef GL_ES
precision highp float;
#else
precision mediump float;
#endif

attribute vec2 aVertexPosition;

uniform float time;

//*** our generated uniforms below:
//uniformStart
uniform float minX;
uniform float minY;
uniform float maxX;
uniform float maxY;
uniform float minZ;
uniform float maxZ;
//uniformEnd

uniform mat4 mvMatrix;
uniform mat4 pMatrix;

varying vec4 vPos;
varying vec3 varData;

varying float vminZ;
varying float vmaxZ;

//random number generator
float myRand(float seed) {
    float part1, result;
    float modded;
    float twoPow;

    twoPow = pow(2.0,16.0);
    part1 = 1664525.0 * seed + 1013904223.0;
    modded = mod(part1,twoPow);

    result = modded / (twoPow - 1.0);
    return result;
}

void main(void) {

    //***Our generated variable declarations
    //varDeclaration
    float x, y;
    //varDeclarationEnd

    float z, xOriginal, yOriginal;
    xOriginal = aVertexPosition[0];
    yOriginal = aVertexPosition[1];

    //the x and y go from -1 to 1 on the master grid, so
    //rescale these to be from -minX to +maxX

    //***Our generated variable assignments
    //varAssignment
    x = ((aVertexPosition[0] + 1.0)/(2.0)) * (maxX - minX) + minX;
    y = ((aVertexPosition[1] + 1.0)/(2.0)) * (maxY - minY) + minY;
    //varAssignmentEnd

    //*** Our generated equation string below:
    //equationString
    z = 2.0 * cos(time + x + y) * (0.5 + (sin(x*x + y*x + time) - 0.5)/(1.0 + 0.1*(x * x + y * y + cos(time)))) + 1.25 * (pow(xOriginal,2.0) + pow(yOriginal,2.0));
    //z = 0.25 * (pow(x,2.0) + pow(y,2.0) + 2.0*cos(time));
    //equationStringEnd

    //z = 0.3 * ((x * sin(sqrt(abs(x - (y + 9.0)))) - (y + 9.0) * sin(sqrt(abs(y + 0.5 * x + 9.0))));
    //z = (pow(x,2.0)/pow(max(maxX,abs(minX)),2.0))*(maxZ-minZ)*0.5 + (pow(y,2.0)/pow(max(maxY,abs(minY)),2.0))*(maxZ-minZ)*0.5 + minZ;

    //scale the z so it fits within our window
    float zScaled = ((z - minZ)/(maxZ - minZ)) * 2.0 + -1.0;

    vec4 position = vec4(aVertexPosition[0],aVertexPosition[1],zScaled,1.0);
    gl_Position = pMatrix * mvMatrix * position;
    vPos = position;

    //** Our generated variable assignment below:
    //varDataAssignment
    varData = vec3((x - minX) / (maxX - minX), (y - minY) / (maxY - minY), 0.0);
    //varDataAssignmentEnd

    //this is mainly for hue calculations when the z window changes
    vminZ = minZ;
    vmaxZ = maxZ;
}
</script>

<script id="shader-box-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#else
precision mediump float;
#endif

varying vec4 vPos;
varying vec3 varData;

varying float vminZ;
varying float vmaxZ;

float convertZToG(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz= vmaxZ - vminZ;
    float degreesPerZ = 630.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return g;
}


float convertZToB(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz= vmaxZ - vminZ;
    float degreesPerZ = 630.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return b;
}


float convertZToR(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.9; v = 0.9;

    float dpz= vmaxZ - vminZ;
    float degreesPerZ = 630.0 / dpz;

    float hueDegrees = z * degreesPerZ + 90.0;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return r;
}

void main(void) {

    //this is always the same, we fill with 0s if there isnt room
    gl_FragColor = vec4(varData[0],varData[1],varData[2],1.0);

    //hueStart
    float z = (vPos[2] + 1.0) * 2.0;
    float r,g,b;
    r = convertZToR(z);
    g = convertZToG(z);
    b = convertZToB(z);
    gl_FragColor = vec4(r,g,b,1);
    //hueEnd

    //gl_FragColor = vec4(varData[0],varData[1],varData[2],1.0);

}

</script>


<script type="text/javascript">
//good equations:
//z = sin(5.5*x - time)*cos(5.0*y + time)+0.5*x*x+ abs(y) - 1.0
//z = sin(pow(x,2.0) + pow(y,2.0) + time) / (abs(x*y) + 1.0) + 0.65 * (x*x/9.0 + y*y/9.0)
//z = 0.0 - sin(x*y + time) + (cos(time) * pow(x/3.0,2.0) + pow(y/3.0,2.0)) + 0.5*cos(x * y * 3.0 + time * 2.0)
//z = 0.5*sqrt(x * y + y *y)+ 1.0 * sin(sqrt(x*x + y*y) + time)  + 0.8*(pow(x/3.0,0.5) + pow(y/3.0,0.5)) - 1.5 + 0.5*cos(x)


$j = jQuery.noConflict();

//globals
var boxTimeout = null;
var notifyTimeout = null;

var shouldCircuit = false;
var thePopup = null;
var canvas = null;

var equationTimeout = null;
var lastEquation = "";

function zeroPad(num,count)
{
    var numZeropad = String(num);
    while(numZeropad.length < count) {
        numZeropad = "0" + numZeropad;
    }
    return numZeropad;
}

function startWaiting() {
    //first time loading, do some formatting stuff

    //make sure the loading gif appears
    $j('#timeoutGif').addClass('timeoutLoading');
    //and change our equation status to waiting
    $j('#equationStringTextArea').addClass('textareaWaiting');
    $j('#equationStringTextArea').removeClass('textareaBadEquation');
}

function startOrResetTimeout() {
    if(equationTimeout)
    {
        clearTimeout(equationTimeout);
    }
    else
    {
        startWaiting();
    }

    equationTimeout = setTimeout('equationStringEdit();',1000);
}

function stopWaiting() {
    //hide loading gifs
    $j('#timeoutGif').removeClass('timeoutLoading');
    equationTimeout = null;
    $j('#equationStringTextArea').removeClass('textareaWaiting');
}

function equationStringEdit() {
    stopWaiting();

    var newEquation = $j('#equationStringTextArea').val();

    //if this equation is the same, peace out
    if(newEquation.replace(/\s/g,'') == lastEquation)
    {
        console.log("no change in equation, peace");
        return;
    }

    //first validate
    Problem.prototype.validateEquationString(newEquation);

    //then try doing it
    if(buildProblem(newEquation))
    {
        //good equation -- the default style is "good equation"
        lastEquation = newEquation.replace(/\s/g,'');
        //so just return
    }
    else
    {
        //bad equation
        $j('#equationStringTextArea').addClass('textareaBadEquation');
    }
}

function buildProblem(equationString) {
    var newProb;
    var newTemplate;
    var newSolver;

    try {
        console.log("making new prob with",equationString);
        newProb = new Problem(equationString,['g']);
        newTemplate = new ShaderTemplateRenderer(newProb);
        newSolver = newTemplate.solver;
    } catch(e) {
        console.log("NEW PROBLEM FAILED");
        return null;
    }

    console.log("new problem success!!");
    //these are valid so switch over
    prob = newProb;
    template = newTemplate;
    solver = newSolver;
    return true;
}

function initGL(canvas) {
    try {
        //webgl context attributes!!
        gl = canvas.getContext("experimental-webgl",{
                                preserveDrawingBuffer:true,
                                antialias:false,
                                });
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {
        if (!gl || /Firefox/.test(navigator.userAgent)) {

            if(/Safari/.test(navigator.userAgent))
            {
                window.location = "http://petercottle.com/friendMapper2/safari.html";
            }
            else
            {
                window.location = "http://petercottle.com/friendMapper2/browserFail.html";
            }
        }
    }
}

function onMouseWheel(event) {

    var toZoom = 0;
    if(event.originalEvent.wheelDeltaY)
    {
        toZoom = event.originalEvent.wheelDeltaY * 0.003;
    }
    else
    {
        //friggin firefox...
        toZoom = -1 * event.originalEvent.detail * 0.06;
    }

    //zoomAmount += toZoom;
    scaleAmount += toZoom / 100;

    if(scaleAmount < 0.0001)
    {
        scaleAmount = 0.0001;
    }
}

function resizeWindow()
{
    //fix other frame buffer size...?
    initOtherFrameBuffer();

    //window sizes
    var wHeight = $j(window).height();
    var wWidth = $j(window).width();

    //viewport sizes
    vHeight = wHeight;
    vWidth = Math.round(wWidth / 2);

    //set the width to the canvas
    $j('#earth-canvas').attr('width',String(vWidth) + 'px');
    $j('#earth-canvas').attr('height',String(vHeight) + 'px');

    gl.viewportWidth = vWidth;
    gl.viewportHeight = vHeight; 
    gl.viewport(0,0,vWidth,vHeight);

    //mat4.perspective(45,gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.ortho(-0.0519,0.0519,-0.0414,0.0414,0.1,100.0,pMatrix);

    $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    //fix loading gif
}


var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var earthRotationMatrix = mat4.create();
mat4.identity(earthRotationMatrix);

function handleMouseDown(event) {
    //event.preventDefault();
    mouseDown = true;

    //otherwise, move with mouse
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}


function handleMouseUp(event) {
    mouseDown = false;
}


function handleMouseMove(event) {
    //phantom events
    if(event.clientX == lastMouseX && event.clientY == lastMouseY)
    {
        return;
    }

    if (!mouseDown) {
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        return;
    }
    //this here only executes when we are clicking and dragging mouse

    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;
    var deltaY = newY - lastMouseY;

    globalYrotate += deltaX / 10;
    globalXrotate += deltaY / 10;

    if(globalXrotate > angleLimit)
    {
        globalXrotate = angleLimit;
    }
    else if (globalXrotate < -angleLimit)
    {
        globalXrotate = -angleLimit;
    }

    lastMouseX = newX
    lastMouseY = newY;
}


function startLoadingWithText(theText) {
    startLoading();
    topNotify(theText);
}

function stopLoadingWithText() {
    stopLoading();
    topNotifyClear();
}

function topNotifyClear() {
    $j('#topNotifyBar').html('');
    $j('#topNotifyBarHolder').addClass('topNotifyBarHidden');
}

function startLoading() {
    isLoading = true;

    var wHeight = $j(window).height();
    var wWidth = $j(window).width();
    $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    $j('.loadingGif').fadeIn();
}

function stopLoading() {
    isLoading = false;
    $j('.loadingGif').fadeOut();
}


function topNotify(theText) {
    topNotifyHtml("<h1>" + theText + "</h1>");
}

function topNotifyHtml(theText) {
    //and if someone is clicking fast, get rid of it
    if(notifyTimeout)
    {
        clearTimeout(notifyTimeout);
    }

    //basically, if its already displayed, hide it and come back in 700ms
    if(!$j('#topNotifyBarHolder').hasClass('topNotifyBarHidden'))
    {
        //clear and come back
        topNotifyClear();
        var jsToExecute = "topNotifyHtml('" + theText + "');";
        notifyTimeout = setTimeout(jsToExecute,700);
        return;
    }

    $j('#topNotifyBar').html("<h1>" + theText + "</h1>");

    $j('#topNotifyBarHolder').removeClass('topNotifyBarHidden');
}

$j(document).ready(function(){
    TWEEN.start();
    webGLStart();

    //$j(window).resize(function(){resizeWindow();});
    //initial resize
    resizeWindow();

    $j('#earth-canvas').bind('mousewheel',onMouseWheel);
    $j('#earth-canvas').bind('DOMMouseScroll',onMouseWheel);

    //default viewport sizes
    gl.viewportHeight = 300;
    gl.viewportWidth = 300;

    $j('#earth-canvas')[0].width = 300;
    $j('#earth-canvas')[0].height = 300;

    eq = "z = 2.0 * cos(time + x + y) * (0.5 + (sin(x*x + y*x + time) - 0.5)/(1.0 + 0.1*(x * x + y * y + cos(time)))) + g * 1.25 * (pow(xOriginal,2.0) + pow(yOriginal,2.0))";
    prob = new Problem(eq,['g']);
    template = new ShaderTemplateRenderer(prob);
    solver = template.solver; solver.solvePass(); 
    drawScene = drawScene2;

    $j('#equationStringTextArea').keydown(function() { startOrResetTimeout(); });
    lastEquation = $j('#equationStringTextArea').val().replace(/\s/g,'');

    $j('#providedEquations').change(function(e) { console.log(e); });

});

</script>


</head>


<body>


<div id="bottomControlHolder" class="buttonGradient smooth">
    <h1>Equation:</h1>
    <textarea rows="4" id="equationStringTextArea" class="validEquation">Equation here!</textarea>

    <img id="timeoutGif" src="equationTimeout.gif" class="equationTimeout smooth" />

    <select id="providedEquations">
        <option value="z = sin(5.5*x - time)*cos(5.0*y + time)+0.5*x*x+ abs(y) - 1.0">Wavy</option>
        <option value="z = sin(pow(x,2.0) + pow(y,2.0) + time) / (abs(x*y) + 1.0) + 0.65 * (x*x/9.0 + y*y/9.0)">Fun one</option>
        <option value="z = 0.0 - sin(x*y + time) + (cos(time) * pow(x/3.0,2.0) + pow(y/3.0,2.0)) + 0.5*cos(x * y * 3.0 + time * 2.0)">Mini Boss</option>
        <option value="z = 0.5*sqrt(x * y + y *y)+ 1.0 * sin(sqrt(x*x + y*y) + time)  + 0.8*(pow(x/3.0,0.5) + pow(y/3.0,0.5)) - 1.5 + 0.5*cos(x)">Gogogogo</option>
    </select>

    <table style="width:100%;margin-bottom:10px;">
        <tr style="width:100%;text-align:center">
            <td class="controlCol">
                <h4>Search Variables</h4>
            </td>
            <td class="controlCol">
                <h4>Fixed / Constant Variables</h4>
            </td>
        </tr>
        <tr style="width:100%;text-align:center">
            <td class="controlCol">
                <div id="sampleVariablesList">

                </div>
            </td>
            <td class="controlCol">
                <div id="fixedVariablesList">

                </div>
            </td>
        </tr>
    </table>

</div>

<canvas id="earth-canvas" width="500px" height="500px"></canvas>

<div id="holder-for-screenshots">
</div>

<img src="loading.gif"class="loadingGif"/>

<div id="topNotifyBarWrapper" style="width:100%;text-align:center;position:absolute;top:0px;">
    <div id="topNotifyBarHolder" class="buttonGradient smooth topNotifyBar topNotifyBarHidden bubbleToStop" onclick="topNotifyClear()" style="display:inline-block;cursor:pointer">
        <div id="topNotifyBar">

        </div>
    </div>
</div>

</body>

</html>
