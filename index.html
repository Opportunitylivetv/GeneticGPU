<html>

<head>
<title> Friend Mapper!</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta property="og:title" content="Friend Mapper"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://petercottle.com/friendMapper2/index.html"/>
<meta property="og:image" content="http://petercottle.com/friendMapper2/friendMapperIcon.PNG"/>
<meta property="og:site_name" content="FriendMapper"/>
<meta property="og:description" content="Map your friends in 3D with WebGl and the Facebook Graph API! Coded by Peter Cottle"/>

<link href="style.css" rel="stylesheet" type="text/css"/>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="Tween.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

<script id="white-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
</script>

<script id="white-fs" type="x-shader/x-fragment">

precision mediump float;

void main(void) {
    gl_FragColor = vec4(1,1,1,1);
}

</script>

<script id="shader-box-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

varying vec4 vColor;
varying vec4 vPos;

float convertZToG(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return g;
}


float convertZToB(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return b;
}


float convertZToR(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return r;
}


void main(void) {
    float x, y, z;
    x = aVertexPosition[0];
    y = aVertexPosition[1];
    z = 0.0;

    //z = pow(x,2.0) + pow(y,2.0);
    z = 0.5 + (sin(x*x + y*x) - 0.5)/(1.0 + 0.1*(x * x + y * y));

    float r,g,b;

    r = convertZToR(z);
    g = convertZToG(z);
    b = convertZToB(z);

    vec4 position = vec4(x,y,z,1.0);

    gl_Position = uPMatrix * uMVMatrix * position;

    //gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

    vColor = aVertexColor;

    vPos = position;
    vColor = vec4(r,g,b,0.9);
}
</script>

<script id="shader-box-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;
varying vec4 vPos;

float convertZToG(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return g;
}


float convertZToB(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return b;
}


float convertZToR(float z)
{
    float h, s, v;
    float f, p, q, t;
    float r,g,b;
    int i;

    //ok so first we need to map the z value to a number of degrees
    //
    //then with that number of degrees, we need to reduce that to
    //0 ->360
    //
    //then, we need to map this to an RGB value with the color
    //conversion formulas

    s = 0.8; v = 0.8;

    float dpz=2.0;
    float degreesPerZ = 360.0 / dpz;

    float hueDegrees = z * degreesPerZ;

    //limit to 0->360
    hueDegrees -= 360.0 * floor(hueDegrees / 360.0);

    h = hueDegrees;
    h /= 60.0;
    i = int(floor(h));
    f = h - float(i);
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    //switch(i)
    if(i == 0)
    {
        r = v;
        g = t;
        b = p;
    }
    else if(i == 1)
    {
        r = q;
        g = v;
        b = p;
    }
    else if(i == 2)
    {
        r = p;
        g = v;
        b = t;
    }
    else if(i == 3)
    {
        r = p;
        g = q;
        b = v;
    }
    else if(i == 4)
    {
        r = t;
        g = p;
        b = v;
    }
    else // i == 5
    {
        r = v;
        g = p;
        b = q;
    }
    return r;
}



void main(void) {
    float z = vPos[2];
    float r,g,b;

    r = convertZToR(z);
    g = convertZToG(z);
    b = convertZToB(z);

    gl_FragColor = vec4(r,g,b,1);
    //gl_FragColor = vec4(z,0,0,1);
    //gl_FragColor = vColor;
}

</script>


<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 vNormal;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        float intensity = 1.05 - dot(vNormal,vec3(0,0,1));
        vec3 atmosphere = vec3(1,1,1) * pow(intensity,3.0);
        //gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting + atmosphere, textureColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 vNormal;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;

            vec3 transformedNormal = uNMatrix * aVertexNormal;
            vNormal = transformedNormal;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
    }
</script>


<script type="text/javascript">

var gl;
$j = jQuery.noConflict();

//arc dimensions and colors
var arcBaseRadius = 2;
var arcBaseThickness = 0.04;
var arcBaseHeight = 0.1;

var arcAlpha = 0.75;

var bubbleTheme = 'all-blue';
var white = [1,1,1,arcAlpha];
var blue = [0,0,1,arcAlpha];
var green = [0,1,0,arcAlpha];
var red = [1,0,0,arcAlpha];
var yellow = [1,1,0,arcAlpha];

//globals
var boxTimeout = null;
var notifyTimeout = null;
var globalColorTaken = {};
var globalColorLookup = {};


var shouldCircuit = false;
var thePopup = null;
var canvas = null;

var arcUnderMouse = null;

var masterArcList = [];

//camera stuff
var zoomAmount = -4;
var currentZoomLevel = -6;

var scaleAmount = 1;
var ourScaleTween = null;
var scaleVariablesForTween = null;

var globalYrotate = 0;
var globalXrotate = 0;
var angleLimit = 85;
var rotateOn = false;

var rotVariablesForTween = {'x':globalXrotate,'y':globalYrotate};
var ourTween = null;
var tweenTime = 1000;
var tweenEasing = TWEEN.Easing.Cubic.EaseInOut;
var ourTweenOn = false;
var timeoutMinutes = 10;


/*****************CLASSES*******************/

function arcObj(gpsFrom,gpsTo,baseRadius,startColor,endColor,thickness,maxHeight) {
    this.alternateForStrips = false;
    this.gpsFrom = gpsFrom;
    this.gpsTo = gpsTo;
    this.baseRadius = baseRadius;
    this.startColor = startColor;
    this.endColor = endColor;
    this.isDoneAnimating = false;
    this.animateDirection = 1;
    this.thickness = thickness;
    this.divisions = 25;
    this.maxHeight = maxHeight;
    this.isHidden = false;

    //animate stuff
    this.animateStep = 0;
    this.totalAnimateSteps = null;
    this.animateVertexAmount = 0;

    //find the vectors
    var pos1 = getPosFromGps(gpsFrom);
    var pos2 = getPosFromGps(gpsTo);

    //our vectors are the normalized versions of these
    this.startVec = vec3.create();
    vec3.normalize(pos1,this.startVec);

    this.endVec = vec3.create();
    vec3.normalize(pos2,this.endVec);

    this.crossVec = vec3.create();
    vec3.cross(this.startVec,this.endVec,this.crossVec);
    vec3.normalize(this.crossVec);
    
    //get the total amount of angle between
    var dotProduct = vec3.dot(this.startVec,this.endVec);
    var dotProductNormal = dotProduct / (vec3.length(this.startVec) * vec3.length(this.endVec));

    this.totalTheta = Math.acos(dotProductNormal);
    this.currentTheta = 0;

    //make the buffers
    this.myVertexBuffer = gl.createBuffer();
    this.myNormalBuffer = gl.createBuffer();
    this.myColorBuffer = gl.createBuffer();
    this.myPickBuffer = gl.createBuffer();

    this.myVertices = [];
    this.myNormals = [];
    this.myColors = [];
    this.myPickColors = [];

    //for the picking
    this.uniqueColor = getUniqueColorObject();
    this.cString = this.uniqueColor.cString;

    globalColorLookup[this.uniqueColor.cString] = this;
}

arcObj.prototype.initAnimate = function () {
    //ok so the initial animate thing is dependent on the number of divisions
    this.totalAnimateSteps = this.divisions;
    this.animateStep = 0;

}

arcObj.prototype.expandArc = function () {
    this.isHidden = false;
    this.isDoneAnimating = false;
    this.animateDirection = 1;
    this.animateStep = 0;
}

arcObj.prototype.retractArc = function () {
    this.isDoneAnimating = false;
    this.animateDirection = -4;
}

arcObj.prototype.hideArc = function () {
    this.isDoneAnimating = true;
    this.isHidden = true;
    this.animateVertexAmount = 0;
}

arcObj.prototype.animateArc = function() {
    //check in case we got called badly
    if(this.isDoneAnimating)
    {
        return true;
    }
    //ok so i did a bit of refactoring here. animateArc doesn't do any of the complicated
    //math to generate the points, it just decides which points to display.

    //ok so basically we just have two triangles per division, so update that number
    this.animateStep += this.animateDirection;
    this.animateVertexAmount = this.animateStep * 2;

    //if we are done
    if(this.animateStep >= this.totalAnimateSteps || this.animateStep <= 0)
    {
        //set the right flag and return
        this.isDoneAnimating = true;
        if(this.animateStep == 0)
        {
            this.isHidden = true;
        }
        return true;
    }
    //still have more to go
    return false;

}

arcObj.prototype.fixHeightAndWidth = function () {
    //adjust the maxheight and width depending on how long this thing is

    //basically, this is a function of theta. we scale width and height
    //depending on how short or long the thing is

    //ok so basically, we need to scale height up if its bigger and scale it down if
    //its smaller

    //get a number between 0 and 1 for how "long" the arc is
    //the max theta between two vectors on a plane is just pi
    var ourModifier = (this.totalTheta / (Math.PI));

    //now scale between -1 and 1
    var ourDelta = (ourModifier - 0.5) * 2;

    //now scale height
    this.maxHeight = this.maxHeight * 0.05 + this.maxHeight * ourModifier;

    //fix our width too
    this.thickness = this.thickness * 0.1 + this.thickness * ourModifier * 2;

    //also our divisions
    this.divisions = Math.round(200 * ourModifier) + 2;

}

arcObj.prototype.buildArc = function () {
    //this method generates the points and does some house keeping
    this.fixHeightAndWidth();
    this.generateArcPoints();
    //refresh buffers?
    this.refreshBuffers();
    this.initAnimate();
}

arcObj.prototype.generateArcPoints = function () {

    //the idea is that we want to loop through theta with the correct number of
    //divisions and generate those points
    for(var genStep = 0; genStep < this.divisions; genStep++)
    {
        //stupid namespace things @_____@
        this.currentTheta = genStep * this.totalTheta / this.divisions;

        var progress = genStep / (this.divisions - 1);

        //ok so we will just compute the vertices for the current theta, add them, and then

        //first get the current radius
        var heightScaleAmount = Math.sin(progress * Math.PI);
        var thisRadius = this.baseRadius + heightScaleAmount * this.maxHeight;
        
        //first scale appropriately
        var adjVec = vec3.create(this.startVec);
        //these look way better with linear interp and sine-based height
        vec3.scale(adjVec,(1-progress));

        var oppVec = vec3.create(this.endVec);
        vec3.scale(oppVec,progress);

        //add these, normalize, scale by radius
        var thisNormal = vec3.create();
        vec3.add(adjVec,oppVec,thisNormal);
        vec3.normalize(thisNormal);

        var thisPoint = vec3.create();
        vec3.scale(thisNormal,thisRadius,thisPoint);
        
        //also get the point that is "thickness" away in cross direction
        var upperNormal = vec3.create(thisNormal);
        var addVec = vec3.create();
        vec3.scale(this.crossVec,this.thickness * heightScaleAmount,addVec);

        //add the addVec to the normal to get the upper point
        vec3.add(upperNormal,addVec,upperNormal);
        vec3.normalize(upperNormal);

        //get the point also
        var upperPoint = vec3.create(upperNormal);
        vec3.scale(upperPoint,thisRadius);
        
        //add them in the right order!
        var firstVertex;
        var secondVertex;
        var firstNormal;
        var secondNormal;

        //goddamnit webgl give me quad strips and not this shit!!!!
        if(!this.alternateForStrips)
        {
            firstVertex = thisPoint;
            secondVertex = upperPoint;
            firstNormal = thisNormal;
            secondNormal = upperNormal;
        }
        else
        {
            firstVertex = upperPoint;
            secondVertex = thisPoint;
            firstNormal = upperNormal;
            secondNormal = thisNormal;
        }
        //wtf why dont i have to do this?
        //this.alternateForStrips = !this.alternateForStrips;
        
        //these are our points!! yay. add them to the vertices and normals
        this.myVertices.push(firstVertex[0],firstVertex[1],firstVertex[2]);
        this.myNormals.push(firstNormal[0],firstNormal[1],firstNormal[2]);

        //add these points too
        this.myVertices.push(secondVertex[0],secondVertex[1],secondVertex[2]);
        this.myNormals.push(secondNormal[0],secondNormal[1],secondNormal[2]);

        //Colors!!
        var thisColor = [];
        for(var i = 0; i < 4; i++)
        {
            thisColor[i] = this.startColor[i] * Math.cos(this.currentTheta) + 
                            this.endColor[i] * Math.sin(this.currentTheta);
            //try out linear?
            thisColor[i] = this.startColor[i] * (1-progress) +
                            this.endColor[i] * (progress);
        }

        //push the color twice
        this.myColors.push(thisColor[0],thisColor[1],thisColor[2],thisColor[3]);
        this.myColors.push(thisColor[0],thisColor[1],thisColor[2],thisColor[3]);

        //push our unique color twice. dont forget about alpha!
        this.myPickColors.push(this.uniqueColor.rFloat,this.uniqueColor.gFloat,this.uniqueColor.bFloat,1);
        this.myPickColors.push(this.uniqueColor.rFloat,this.uniqueColor.gFloat,this.uniqueColor.bFloat,1);

    }
    //end of loop, we have filled up all of the arrays
    //now we return and selectively draw to animate

}


arcObj.prototype.refreshBuffers = function () {
    //buffer the data

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myVertices), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myNormals), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myColors), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myPickBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myPickColors), gl.DYNAMIC_DRAW);
 
    //update the sizes
    this.myVertexBuffer.itemSize = 3;
    this.myVertexBuffer.numItems = this.myVertices.length / 3;

    this.myColorBuffer.itemSize = 4;
    this.myColorBuffer.numItems = this.myColors.length / 4;

    this.myNormalBuffer.itemSize = 3;
    this.myNormalBuffer.numItems = this.myNormals.length / 3;

    this.myPickBuffer.itemSize = 4;
    this.myPickBuffer.numItems = this.myPickColors.length / 4;

}

arcObj.prototype.drawArcStrips = function() {
    if(this.isHidden)
    {
        return;
    }
    this.drawArcStripsEither(false);
}

arcObj.prototype.drawArcStripsForPicking = function() {
    this.drawArcStripsEither(true);
}

arcObj.prototype.drawArcStripsWhite = function() {
    //bind buffers, use different program

    gl.bindBuffer(gl.ARRAY_BUFFER,this.myVertexBuffer);
    gl.vertexAttribPointer(whiteShaderProgram.vertexPositionAttribute,this.myVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.animateVertexAmount);

}

arcObj.prototype.drawArcStripsEither = function(forPicking) {
    //we just need to bind our buffers and then draw!

    //need to bind this vertex buffer
    gl.bindBuffer(gl.ARRAY_BUFFER,this.myVertexBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexPositionAttribute,this.myVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    //need to bind this color buffer
    if(!forPicking)
    {
        gl.bindBuffer(gl.ARRAY_BUFFER,this.myColorBuffer);
        gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, this.myColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
    }
    else
    {
        gl.bindBuffer(gl.ARRAY_BUFFER,this.myPickBuffer);
        gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, this.myPickBuffer.itemSize, gl.FLOAT, false, 0, 0);
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.animateVertexAmount);
}


/***************End Classes!*****************************/


/********** Geometry Functions *******/

function getPosFromGps(gpsCoords)
{
    //gives you the position on the sphere (sans radius) from a gps location
    var lat = gpsCoords.latitude;
    var long = gpsCoords.longitude;

    var latRad = lat * Math.PI / 180;
    var longRad = long * Math.PI / 180;

    var theta = Math.PI/2 - latRad;
    var phi = Math.PI - longRad;

    var x = Math.cos(phi) * Math.sin(theta);
    var y = Math.cos(theta);
    var z = Math.sin(phi) * Math.sin(theta);

    var returnVec = vec3.create([x,y,z]);
    return returnVec;
}

function myColorRand() {
    return Math.round(Math.random() * 255);
}

function zeroPad(num,count)
{
    var numZeropad = String(num);
    while(numZeropad.length < count) {
        numZeropad = "0" + numZeropad;
    }
    return numZeropad;
}

function getRandomColor() {
    var r = myColorRand(); var rS = zeroPad(r,3);
    var g = myColorRand(); var gS = zeroPad(g,3);
    var b = myColorRand(); var bS = zeroPad(b,3);
    var rFloat = r / 255;
    var gFloat = g / 255;
    var bFloat = b / 255;
    
    var cString = rS + gS + bS;

    return {'r':r,'g':g,'b':b,'cString':cString,
            'rFloat':rFloat,'gFloat':gFloat,'bFloat':bFloat};
}

function getUniqueColorObject()
{
    //make a color object that doesnt exist, and go store it
    var aColor = getRandomColor();
    while(globalColorTaken[aColor.cString])
    {
        aColor = getRandomColor();
    }
    //ready for return
    globalColorTaken[aColor.cString] = true;
    return aColor;
}


/*******************Geometry Functions******************/

function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl",{preserveDrawingBuffer:true});
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {
    }
    if (!gl || /Firefox/.test(navigator.userAgent)) {

        if(/Safari/.test(navigator.userAgent))
        {
            window.location = "http://petercottle.com/friendMapper2/safari.html";
        }
        else
        {
            window.location = "http://petercottle.com/friendMapper2/browserFail.html";
        }
    }
}

function determineIfInPopup(eventFragment) {
    if(!eventFragment)
    {
        return false;
    }
    //console.log("This level class " + eventFragment.className);
    if(/bubble/.test(eventFragment.className))
    {
        return true;
    }
    //dig deeper
    return determineIfInPopup(eventFragment.parentNode);
}

function onMouseWheel(event) {

    //first, check if this was a scroll inside a popup thing
    if(event.originalEvent && event.originalEvent.srcElement)
    {
        if(determineIfInPopup(event.originalEvent.srcElement))
        {
            //console.log("was in bubble div");
            //dont do stupid zoom stuff
            return;
        }
        else
        {
            //console.log("not in bubble div");
        }
    }

    var toZoom = 0;
    if(event.originalEvent.wheelDeltaY)
    {
        toZoom = event.originalEvent.wheelDeltaY * 0.003;
    }
    else
    {
        //friggin firefox...
        toZoom = -1 * event.originalEvent.detail * 0.06;
    }

    zoomAmount += toZoom;
    if(zoomAmount > -2.76)
    {
        zoomAmount = -2.76;
    }
}

function resizeWindow()
{
    //fix other frame buffer size...?
    initOtherFrameBuffer();

    //window sizes
    var wHeight = $j(window).height();
    var wWidth = $j(window).width();

    //viewport sizes
    vHeight = wHeight;
    vWidth = wWidth;

    //set the width to the canvas
    $j('#earth-canvas').attr('width',String(vWidth) + 'px');
    $j('#earth-canvas').attr('height',String(vHeight) + 'px');

    gl.viewportWidth = vWidth;
    gl.viewportHeight = vHeight; 
    gl.viewport(0,0,vWidth,vHeight);

    mat4.perspective(45,gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

    setMatrixUniforms();


     $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    //fix loading gif
    
}


function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//global colors
var ambientR = 0.5;
var ambientG = 0.7;
var ambientB = 1.2;

var lDirectionX = -1.0;
var lDirectionY = -1.0;
var lDirectionZ = -1.0;

var lightingDirection = [
    lDirectionX,
    lDirectionY,
    lDirectionZ
];

var lColorR = 0.8;
var lColorG = 0.8;
var lColorB = 0.8;

var blendShaderProgram;
var whiteShaderProgram;

function initShaders() {
    //earth shader
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    //atmosphere shader
    var atmosphereVertexShader = getShader(gl,"shader-atmosphere-vs");
    var atmosphereFragShader = getShader(gl,"shader-atmosphere-fs");

    //box shadeer
    var blendVertexShader = getShader(gl, "shader-box-vs");
    var blendFragShader = getShader(gl, "shader-box-fs");

    //white shader
    var whiteVertexShader = getShader(gl, "white-vs");
    var whiteFragShader = getShader(gl, "white-fs");

    whiteShaderProgram = gl.createProgram();
    gl.attachShader(whiteShaderProgram, whiteVertexShader);
    gl.attachShader(whiteShaderProgram, whiteFragShader);
    gl.linkProgram(whiteShaderProgram);

    blendShaderProgram = gl.createProgram();
    gl.attachShader(blendShaderProgram, blendVertexShader);
    gl.attachShader(blendShaderProgram, blendFragShader);
    gl.linkProgram(blendShaderProgram);

    if (!gl.getProgramParameter(whiteShaderProgram, gl.LINK_STATUS) || 
            !gl.getProgramParameter(blendShaderProgram, gl.LINK_STATUS)){
        alert("Could not initialise shaders");
    }

    //our arcs
    gl.useProgram(blendShaderProgram);

    blendShaderProgram.vertexPositionAttribute = gl.getAttribLocation(blendShaderProgram,"aVertexPosition");
    gl.enableVertexAttribArray(blendShaderProgram.vertexPositionAttribute);

    blendShaderProgram.vertexColorAttribute = gl.getAttribLocation(blendShaderProgram,"aVertexColor");
    gl.enableVertexAttribArray(blendShaderProgram.vertexColorAttribute);

    blendShaderProgram.pMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uPMatrix");
    blendShaderProgram.mvMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uMVMatrix");


    //white shader
    gl.useProgram(whiteShaderProgram);

    whiteShaderProgram.vertexPositionAttribute = gl.getAttribLocation(whiteShaderProgram,"aVertexPosition");
    gl.enableVertexAttribArray(whiteShaderProgram.vertexPositionAttribute);

    whiteShaderProgram.pMatrixUniform = gl.getUniformLocation(whiteShaderProgram,"uPMatrix");
    whiteShaderProgram.mvMatrixUniform = gl.getUniformLocation(whiteShaderProgram,"uMVMatrix");

}


function handleLoadedTexture(texture) {
    stopLoadingWithText();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindTexture(gl.TEXTURE_2D, null);

    doEarthFlyin();
    tick();
}


var earthTexture;

var otherFramebuffer;
var otherTexture;

function initOtherFrameBuffer() {
    //make frame buffer
    otherFramebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,otherFramebuffer);
    otherFramebuffer.width = $j(window).width();
    otherFramebuffer.height = $j(window).height();

    //make texture
    otherTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, otherTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);

    //set it to rgba
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, otherFramebuffer.width, otherFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    //something with a render buffer?
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, otherFramebuffer.width, otherFramebuffer.height);

    //for texture? set attached depth buffer also?
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, otherTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    //reset back to default
    gl.bindTexture(gl.TEXTURE_2D,null);
    gl.bindRenderbuffer(gl.RENDERBUFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function initTexture() {
    earthTexture = gl.createTexture();
    earthTexture.image = new Image();
    earthTexture.image.onload = function () {
        handleLoadedTexture(earthTexture)
    }

    earthTexture.image.src = "world.jpg";
    startLoadingWithText("Initializing WebGL...");
}

var mvMatrix = mat4.create();
var mvMatrixStack = [];
var pMatrix = mat4.create();

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

function setMatrixUniforms() {

    gl.uniformMatrix4fv(blendShaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(blendShaderProgram.mvMatrixUniform, false, mvMatrix);

    gl.uniformMatrix4fv(whiteShaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(whiteShaderProgram.mvMatrixUniform, false, mvMatrix);
}


function degToRad(degrees) {
    return degrees * Math.PI / 180;
}


var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var earthRotationMatrix = mat4.create();
mat4.identity(earthRotationMatrix);

function handleMouseDown(event) {
    //event.preventDefault();
    mouseDown = true;

    if(event.which == 1)
    {
        //primary click
        
        //dont do anything if we are inside a bubble thing
        if(determineIfInPopup(event.srcElement))
        {
            return;
        }

        mouseClickPick(event);
        //return;
    }

    //otherwise, move with mouse
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}


function handleMouseUp(event) {
    mouseDown = false;
}


function handleMouseMove(event) {
    //phantom events
    if(event.clientX == lastMouseX && event.clientY == lastMouseY)
    {
        return;
    }

    if (!mouseDown) {
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        return;
    }
    //this here only executes when we are clicking and dragging mouse

    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;
    var deltaY = newY - lastMouseY;

    globalYrotate += deltaX / 10;
    globalXrotate += deltaY / 10;

    if(globalXrotate > angleLimit)
    {
        globalXrotate = angleLimit;
    }
    else if (globalXrotate < -angleLimit)
    {
        globalXrotate = -angleLimit;
    }

    lastMouseX = newX
    lastMouseY = newY;
}



var earthVertexPositionBuffer;
var earthVertexNormalBuffer;
var earthVertexTextureCoordBuffer;
var earthVertexIndexBuffer;

var gridVertexPositionBuffer;
var gridVertexColorBuffer;

var vertices;
var colors;

function initGridBuffers() {

    //initialize the grid vertices
    var gridVertexPositions = [];
    var gridVertexColors = [];

    var addPointsToBuffer = function() {
        for(var temp = 0; temp < arguments.length; temp++)
        {
            point = arguments[temp];
            gridVertexPositions.push(point.x, point.y, 0);
            var colors = [];
            if(temp == 0)
            {
                colors = [1, 0, 0, 1];
            }
            else if(temp == 1)
            {
                colors = [0, 1, 0, 1];
            }
            else
            {
                colors = [0, 0, 1, 1];
            }

            gridVertexColors = gridVertexColors.concat(colors);
        }
    };
    var makePoint = function(x,y) {
        return {'x':x,'y':y};
    };

    var numRows = 20.0;
    var xMin = -1;
    var xMax = 1;
    var yMin = -1;
    var yMax = 1;

    var xDivisor = (xMax - xMin) / numRows;
    console.log(xDivisor);
    var yDivisor = (yMax - yMin) / numRows;
    //the x loop
    for(var i = 0; i < numRows; i++)
    {
        //the y loop
        for(var j = 0; j < numRows; j++)
        {
            var xHere = i * xDivisor + xMin;
            var yHere = j * yDivisor + yMin;

            var xAcross = (i + 1) * xDivisor + xMin;
            var yAcross = (j + 1) * yDivisor + yMin;

            var pHere = makePoint(xHere,yHere);
            var pAbove = makePoint(xHere,yAcross);
            var pRight = makePoint(xAcross,yHere);
            var pDiagonal = makePoint(xAcross,yAcross);

            addPointsToBuffer(pHere,pDiagonal,pAbove);
            addPointsToBuffer(pHere,pRight,pDiagonal);
        }
    }

    //gridVertexPositions = [1,1,0,-1,-1,0,-1,1,0];
    //gridVertexColors = [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1];

    gridVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVertexPositions), gl.STATIC_DRAW);
    gridVertexPositionBuffer.itemSize = 3;
    gridVertexPositionBuffer.numItems = gridVertexPositions.length / 3;

    gridVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVertexColors), gl.STATIC_DRAW);
    gridVertexColorBuffer.itemSize = 4;
    gridVertexColorBuffer.numItems = gridVertexColors.length / 4;

}

function startLoadingWithText(theText) {
    startLoading();
    topNotify(theText);
}

function stopLoadingWithText() {
    stopLoading();

    topNotifyClear();
}

function topNotifyClear() {
    $j('#topNotifyBar').html('');
    $j('#topNotifyBarHolder').addClass('topNotifyBarHidden');
}

function startLoading() {
    isLoading = true;

    var wHeight = $j(window).height();
    var wWidth = $j(window).width();
    $j('.loadingGif').css('left',String(wWidth/2 - 220*0.5) + 'px');
    $j('.loadingGif').css('top',String(wHeight / 2 - 19*0.5) + 'px');
    $j('.loadingGif').fadeIn();
}

function stopLoading() {
    isLoading = false;
    $j('.loadingGif').fadeOut();
}


function topNotify(theText) {
    topNotifyHtml("<h1>" + theText + "</h1>");
}

function topNotifyHtml(theText) {
    //and if someone is clicking fast, get rid of it
    if(notifyTimeout)
    {
        clearTimeout(notifyTimeout);
    }

    //basically, if its already displayed, hide it and come back in 700ms
    if(!$j('#topNotifyBarHolder').hasClass('topNotifyBarHidden'))
    {
        //clear and come back
        topNotifyClear();
        var jsToExecute = "topNotifyHtml('" + theText + "');";
        notifyTimeout = setTimeout(jsToExecute,700);
        return;
    }

    $j('#topNotifyBar').html("<h1>" + theText + "</h1>");

    $j('#topNotifyBarHolder').removeClass('topNotifyBarHidden');
}


function mouseClickPick(event) {
    //get the coordinates on our canvas
    var x = event.clientX;
    var y = event.clientY;

}

function getArcAtMousePos(x,y) {
    //flip y
    y = gl.viewportHeight - y;

    //real quick, render the frame but in pick mode into another buffer!
    gl.bindFramebuffer(gl.FRAMEBUFFER, otherFramebuffer);
    drawSceneIntoOtherBuffer();

    //go get the pixel data from the frame buffer
    var pixelValues = new Uint8Array(4);
    gl.readPixels(x,y,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixelValues);

    //now switch back
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    //console.log("R:" + pixelValues[0] + " G:" + pixelValues[1] + " B:" + pixelValues[2]);

    var r = pixelValues[0]; var rS = zeroPad(r,3);
    var g = pixelValues[1]; var gS = zeroPad(g,3);
    var b = pixelValues[2]; var bS = zeroPad(b,3);

    //get the string for this
    var cString = rS + gS + bS;
    
    //see if its there
    if(globalColorTaken[cString])
    {
        //also tell who it is
        var theArc = globalColorLookup[cString];
        return theArc;
    }
    return null;
}

function arcClick(anArc)
{
    if(anArc.myConnection)
    {
        //going there
        fbClickOnArc(anArc);
    }
    else
    {
        tweenToGps(anArc.gpsFrom.latitude,anArc.gpsFrom.longitude);
        anArc.retractArc();
        var showString = "This location at " + anArc.gpsFrom.latitude + " and " + anArc.gpsFrom.longitude;
    }
}

function fbClickOnArc(anArc) {
    //all the stuff for when you click on an arc that has a facebook connection
    var theGps = anArc.myConnection.toPlace.ourGps;
    tweenToGps(theGps.latitude,theGps.longitude);

    //go ahead and build the display string
    var innerHtml = buildHtmlForBubble(anArc.myConnection);
}

function drawSceneIntoOtherBuffer() {
    drawSceneEither(true);
}

function drawScene() {
    drawSceneEither(false);
}

function drawSceneEither(forPicking) {

    cameraPerspectiveClear();
    translateAndRotate();

    gl.useProgram(blendShaderProgram);
    setMatrixUniforms();
    //here, we draw the grid
    drawGrid();

    gl.useProgram(blendShaderProgram);
    setMatrixUniforms();

    //the 1500 is for when it gets crazay
    for(var i = 0; i < masterArcList.length; i++)
    {
        var theArc = masterArcList[i];
        theArc.animateArc();
        if(theArc == arcUnderMouse && !forPicking)
        {
            gl.useProgram(whiteShaderProgram);
            setMatrixUniforms();
            theArc.drawArcStripsWhite();
            gl.useProgram(blendShaderProgram);
            setMatrixUniforms();
        }
        else
        {
            //draw the arc
            if(forPicking)
            {
                theArc.drawArcStripsForPicking();
            }
            else
            {
                theArc.drawArcStrips();
            }
        }
    }

    if(false)
    {
        gl.useProgram(whiteShaderProgram);
        setMatrixUniforms();
        arcUnderMouse.drawArcStripsWhite();
        gl.useProgram(blendShaderProgram);
        setMatrixUniforms();
    }
}

function randomGps() {
    var lat = Math.random() * 180 + -90;
    var long = Math.random() * 360 - 180;

    return {'latitude':lat,'longitude':long};

}

function rubberBandBall() {
    for(var i = 0; i < 50; i++) { generateRandomArc(); }
}

function generateRandomArc() {
    var fromGps = randomGps();
    var toGps = randomGps();

    var thisArc = new arcObj(fromGps,toGps,1,[0,0,1,arcAlpha],[1,1,1,arcAlpha],0.04,0.1);
    thisArc.buildArc();

    masterArcList.push(thisArc);
}

function expandArcsOfList(theList) {
    for(var i = 0; i < theList.length; i++)
    {
        theList[i].expandArc();
    }
}

function retractArcsOfList(theList) {
    for(var i = 0; i < theList.length; i++)
    {
        theList[i].retractArc();
    }
}

function cameraPerspectiveClear() {

    gl.useProgram(blendShaderProgram);
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

    //we set our clearColor to be 0 0 0 0, so its essentially transparent.
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
}


function translateAndRotate() {

    mat4.identity(mvMatrix);

    mat4.translate(mvMatrix, [0, 0, zoomAmount]);

    //cap variables
    if(globalYrotate > 360)
    {
        globalYrotate -= 360;
    }
    if(globalYrotate < -360)
    {
        globalYrotate += 360;
    }

    //do rotation for camera
    var newRot = mat4.create();
    mat4.identity(newRot);

    //now need to get the other axis
    var secondRotAxis = vec3.create();
    var result = vec3.create();
    secondRotAxis[0] = 1;
    mat4.multiplyVec3(newRot,secondRotAxis,result);

    mat4.rotate(newRot,degToRad(globalXrotate), [result[0],result[1],result[2]]);
    mat4.rotate(newRot,degToRad(globalYrotate), [0,1,0]);

    //now multiply earth rotation
    mat4.identity(earthRotationMatrix);
    mat4.multiply(earthRotationMatrix,newRot);

    mat4.scale(mvMatrix,[scaleAmount,scaleAmount,scaleAmount]);

    mat4.multiply(mvMatrix, earthRotationMatrix);
    setMatrixUniforms();
}


function drawGrid() {
    gl.useProgram(blendShaderProgram);
    setMatrixUniforms();

    //need a new buffer for grid positions
    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexPositionAttribute, gridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexColorBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, gridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.drawArrays(gl.TRIANGLES, 0, gridVertexPositionBuffer.numItems);
}


//slowly rotate
function slowRotate()
{
    if(rotateOn)
    {
        globalYrotate += 0.1;
    }
    return;
}

function convertGpsToRotVariables(lat,long) {
    //well globalYrotate is just 90 + that long
    var yRotate = 90 + -long;
    var xRotate = lat;

    return {'xRotate':xRotate,'yRotate':yRotate};
}

function tweenUpdate() {
    globalXrotate = rotVariablesForTween.x;
    globalYrotate = rotVariablesForTween.y;
}

function tweenDone() {
    ourTweenOn = false;
}

function tweenToGps(lat,long) {
    var rotCorrespondingToGps = convertGpsToRotVariables(lat,long);

    //we need to avoid the 360 spin thing
    var ySpin = rotCorrespondingToGps.yRotate;
    var ySpinDistance = ySpin - globalYrotate;

    if(ySpinDistance > 180)
    {
        rotCorrespondingToGps.yRotate -= 360;
    }
    else if (ySpinDistance < -180)
    {
        globalYrotate -= 360;
    }

    //refresh our current rotvaribales
    rotVariablesForTween = {'x':globalXrotate,'y':globalYrotate};

    var x = rotCorrespondingToGps.xRotate;
    var y = rotCorrespondingToGps.yRotate;

    if(ourTween)
    {
        ourTween.stop();
    }

    ourTween = new TWEEN.Tween(rotVariablesForTween).to({x:x,y:y},tweenTime).onUpdate(tweenUpdate).onComplete(tweenDone);
    ourTween.easing(tweenEasing);
    ourTweenOn = true;
    ourTween.start();

}

function tick() {
    requestAnimFrame(tick);
    drawScene();
    slowRotate();
}


function webGLStart() {
    canvas = document.getElementById("earth-canvas");
    initGL(canvas);
    initShaders();
    initGridBuffers();
    initTexture();
    initOtherFrameBuffer();

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.enable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    document.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

}

function doEarthFlyin() {
    scaleAmount = 0.01;
    if(ourScaleTween)
    {
        ourScaleTween.stop();
    }

    scaleVariablesForTween = {'scale':scaleAmount};

    ourScaleTween = new TWEEN.Tween(scaleVariablesForTween).to({'scale':1},tweenTime*1.5).onUpdate(scaleTweenUpdate);
    setTimeout('scaleTweenComplete()',tweenTime*0.5);
    ourScaleTween.easing(TWEEN.Easing.Quartic.EaseInOut);
    ourScaleTween.start();
} 

function scaleTweenComplete()
{
    rubberBandBall();
}

function scaleTweenUpdate() {
    scaleAmount = scaleVariablesForTween.scale;
}

$j(document).ready(function(){
    TWEEN.start();
    webGLStart();

    $j(window).resize(function(){resizeWindow();});
    //initial resize
    resizeWindow();

    //var container = document.getElementById('earth-canvas');
    $j(document).bind('mousewheel',onMouseWheel);
    $j(document).bind('DOMMouseScroll',onMouseWheel);
    

});

</script>


</head>


<body>

    <canvas id="earth-canvas" style="border: none;" width="500px" height="500px"></canvas>

<img src="loading.gif"class="loadingGif"/>

<div id="topNotifyBarWrapper" style="width:100%;text-align:center;position:absolute;top:0px;">
    <div id="topNotifyBarHolder" class="buttonGradient smooth topNotifyBar topNotifyBarHidden bubbleToStop" onclick="topNotifyClear()" style="display:inline-block;cursor:pointer">
        <div id="topNotifyBar">

        </div>
    </div>
</div>

<div id="countdownClockHolder" class="buttonGradient smooth countdownClockHolder">
    <div id="countdownClock" class="countdownClockText">

    </div>
    Until next Query..
</div>


</body>

</html>
